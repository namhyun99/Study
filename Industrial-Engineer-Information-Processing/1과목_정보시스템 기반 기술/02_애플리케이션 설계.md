# 1.소프트웨어 생명 주기 (Software Life Cycle) 및 모형

소프트웨어 생명주기는 소프트웨어 개발 방법론의 바탕이 되는 것으로, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것이다.
- 소프트웨어 수명주기라고도 함
- 소프트웨어 프로세스 모형 또는 소프트웨어 공학 패러다임이라고 함
- 소프트웨어 생명 주기 모형에는 폭포수 모형, 프로토타임 모형, 나선형 모형, 애자일 모형 등이 있음

<br>

### 1.1 소프트웨어 공학의 개념
- 소프트웨어 공학(SE; Software Engineering)은 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문, 여러가지 방법론과 도구, 관리 기법들이 통하여 소프트웨어의 품질과 생산성을 향상시킬 목적
  - IEEE의 소프트웨어 공학 표준 용어사전 : 소프트웨어의 개발, 운용, 유지보스, 폐기 처분에 대한 체계적인 접근 방안
  - Fairley : 지정된 비용과 기간 내에 소프트웨어를 체계적으로 생산하고 유지 보수 하는데 관련된 기술적이고 관리적인 원리
  - Boehm : 과학적인 지식을 소프트웨어 설계과 제작에 응용하는 것이며 이를 개발, 운용, 유지보수하는데 필요한 문서 작성 과정

- 기본 원칙
  - 현대적인 프로그램밍 기술을 계속적으로 적용 (update)
  - 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증 (유지보수)
  - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지 (기록)

<br>

### 1.2 폭포수 모형(Waterfall Model)
- 각 단계를 철처하게 검토하여 승인 과정을 거친 후에 다음단계를 진행하는 개발 방법론
- 소프트웨어 공학에서 가장 오래되고 폭넑게 사용된 전독적인 소프트웨어 생명주기 모형
- 개발 과정의 한 단계가 끝나야만 다음 단계로 넘어갈 수 있는 선형 순차적 모형
- 모형을 적용한 경험과 성공 사례가 많음
- 두 개 이상의 과정이 병행하여 수행되지 않는다.   
<br><img src="https://images.velog.io/images/arittung/post/056810d7-3a43-45ba-9537-8683083de5cf/image.png"><br>

<br>

### 1.3 프로토타입 모형(Prototype Model, 원형 모형)
-  실제 개발될 소프트웨어에 대한 견본(시제)품(Prototype)을 만들어 최종 결과물을 예측하는 모형
- 시제품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발
- 시스템 또는 모형을 만들면서 구현된 소프트웨어를 추후 구현단계에서 사용될 골격 코드가 된다.
- 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보완하기 위한 모형   
<br><img src="https://images.velog.io/images/arittung/post/9610ddef-7674-42cd-8bbd-08ebfb4735e8/image.png"><br>

<br>

### 1.4 나선형 모형(Spiral Model, 점진적 모형)
- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 소프트웨어 개발 시 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적
- 누락되거나 추가된 요구사항을 첨가할 수 있고, 정밀하며, 유지보수 과정이 필요 없다.
- 점진적 모형이라고 함
  - 점진적 모형이란 나선을 따라 돌듯이 여러번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 만들어 내는 것

<br><img src="https://images.velog.io/images/arittung/post/5f1ba257-9ebb-454d-a6c9-1f79d83c540d/image.png">

<br>

### 1.5 애자일 모형(Agile Model)
- 고객의 요구사항 변화에 유연하게 대응할 수 있또록 일정한 주기를 반복하면서 개발과정 진행
- 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭
- 기업 활동 전반에 걸쳐 사용
- 스프린트(Sprint)  또는 이터레이션(Iteration)이라고 불리는 짧은 개발 주기를 반복하며, 반복되는 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구를 적극 수용
- 소규모 프로젝트, 고도로 숙달된 개발자, 급현하는 요구사항에 적합
- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형
  - 스크럼(Scrum)
  - XP(eXtreme Programming)
  - 칸반(Kanban)
  - Lean
  - 크리스탈(Crystal)
  - ASD(Adaptive Software Development)
  - FDD(Feature Driven Development) 기능 중심 개발
  - DSDM(Dynamic System Development Method)
  - DAD(Disciplined Agile Delivery)  - 

<br><img src="https://images.velog.io/images/arittung/post/d939149d-50f0-49f4-9ca0-d95654d1c79c/image.png">

<br>

### 1.6 애자일 개발 4가지 핵심 가치
1. 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
2. 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
3. 계약 협상보다는 고객과 협업에 더 가치를 둔다.
4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다

<br>

### 1.7 애자일 개발 12가지 실행 지침
1. 유용한 소프트웨어를 빠르고, 지속적으로 제공하여 고객을 만족시킨다.
2. 개발 막바지라도 요구사항 변경을 적극 수용한다
3. 몇 개월이 아닌 몇 주 단위로 실행되는 소프트웨어를 제공한다
4. 고객과 개발자가 프로젝트 기간에 함께 일한다.
5. 개발에 대한 참여 의지가 확실한 사람들로 팀을 구성하고, 필요한 개발 환경과 지원을 제공하며, 일을 잘 끝낼 수 있도록 신뢰한다.
6. 같은 사무실에서 얼굴을 맞대고 의견을 나눈다.
7. 개발의 진척도를 확인하는 1차 기준은 작동하는 소프트웨어이다.
8. 지속 가능한 개발을 장려하고 일정한 속도로 개발을 진행한다.
9. 기술적 우수성과 좋은 설계에 지속적인 관심을 기울이면 미첩성이 향상된다.
10. 단순화를 추구한다.
11. 최상의 아키텍처, 명확한 요구사항, 최상의 설계는 자기 스스로 일을 주도하는 조직적인 팀으로부터 나온다
12. 더 효과적인 팀이 될 수 있는 방안을 정기적으로 깊이 고민하고 그에 따라 팀의 행동을 조정한다.

<br>

### 1.8 폭포수 모형과 애자일의 비교
|구분|폭포수 모형|애자일|
|:---|:---|:---|
|새로운 요구사항 반영|어려움|지속적으로 반영|
|고객과의 의사소통|적음|지속적임|
|테스트|마지막에 모든 기능을 테스트|반복되는 일정 주기가 끝날 때마다 테스트|
|개발 중심|계획, 문서(메뉴얼)|고객|

<br>

# 2. 소프트웨어 개발 방법론

소프트웨어 개발, 유지보수 등에 필요한 여러가지 일들의 수행 방법 및 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것
- 소프트웨어의 생산성과 품질 향상이 목적
- 종류에는 구조적 , 정보공학, 객체지향, 컴포넌트 기반(CBD), 애자일, 제품 계열 방법론 등

<br>

### 2.1 구조적 방법론
- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 **문서화하는 처리중심 방법론**
- 1960년대 까지 가장 많이 사용
- 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적
- 복잡한 문제를 다루기 위해 분과 정복(Divide and Conquer)원리를 적용
  
    >**구조적 방법론의 절차**   
    > 타당성 검토 > 계획 > 요구사항 > 설계 > 구현 > 시험 > 운용/유지보수

<br>

### 2.2 정보공학 방법론
- 정형화된 기법들을 상호 연광성 있게 통합 및 적용하는 **자료(Data)중심의 방법론**
- 대규모 정보 시스템을 구축하는데 적합
  
    >**정보공학 방법론의 절차**   
    > 정보 전략 계획 수립 > 업무 영역 분석 > 업무 시스템 설계 > 업무 시스템 구축

<br>

### 2.3 객체지향 방법론
- 기계의 부품을 조립하듯이 **객체(Object)들을 조립**해서 필요한 소프트웨어를 구현하는 방법론
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책
- 구성요소 => 객체(Object), 클래스(Class), 메시지(Message) 등
- 기본원칙 => 캡슐화(Encapsulation), 정보은닉(Information Hiding), 추상화(Abstraction), 상속성(Inheritance), 다형성(Polymorphism) 등

    >**객체지향 방법론의 절차**   
    >요구분석 > 설계 > 구현 > 테스트 및 검증 > 인도

<br>

### 2.4 컴포넌트 기반(CBD; Component Based Design) 방법론
- 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
- 컴포넌트란 문서, 소스코드, 파일, 라이브러리 등과 같은 모듈화된 자원
- `재사용(Reusability)`이 가능하여 시간과 노력을 절감
- **확장성이 보장, 유지 보수 비용을 최소화, 생산성 및 품질 향상**

    >**컴포넌트 기반 방법론의 절차**   
    > 개발준비 > 분석 > 설계 > 구현 > 테스트 > 전개 > 인도

<br>

### 2.5 애자일(Agile) 방법론
- 일정한 주기를 반복하면서 개발 과정을 진행하는 방법론
- 소규모 프로젝트, 고도로 숙달된 개발자, 급현하는 요구사항에 적합
- 대죠적인 종류 => 익스트림 프로그래밍(XP), 스크럼(Scrum), 칸반(Kanban), 크리스탈(Crytal) 등

    >**애자일 방법론의 절차**   
    >사용자 스토리 > [계획 > 개발 > 승인테스트]  []구간 반복

<br>

### 2.6 제품 계열 방법론
- 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 임베디드 소프트웨어를 만드는데 적합

<br>

# 3. 요구사항 정의

- 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건 등을 나타냄
- 요구사항이 제대로 정의되어야만 목표와 계획을 수립할 수 있다.
- 요구사항은 소프트웨어 개발 의뢰자, 개발자, 사용자 등 간의 의사소통을 원활하게 하는데 도움을 준다.


### 3.1 요구사항의 유형

일반적으로 기술하는 내용에 따라 `기능 요구사항` or `비기능 요구사항`으로 구분하며, 기술관점과 대상의 범위에 따란 `시스템 요구사항` or `사용자 요구사항`으로 나눈다.   

<br>

**1. 기능 요구사항 (Functional requirements)**   
- 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
- 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 지장하거나 연산을 수행해야 하는지에 대한 사항
- 시스템이 반드시 수행해야 하는 기능
- 사용자가 시스템을 통해 제공받기를 원하는 기능

<br>

**2. 비기능 요구사항(Non-functional requirements)**   
- 시스템 장비 구성 요구사항 : 하드웨어, 소프트웨어, 네트워크 등의 시스템 장비구성에 대한 요구사항
- 성능 요구사항 : 처리 속도 및 시간 처리량, 동적,정적 적용량, 가용성 등 성능에 대한 요구사항
- 인터페이스 요구사항 : 시스템 <ㅡ> 사용자 인터페이스, 하드웨어 및 통신 인터페이스, 정보교환에 사용되는 프로토콜과의 연계도 포함하여 기술
- 데이터 요구사항 : 초기 자료 구축 및 데이터 변환을 위한 대상, 방법, 보안이 필요한 데이터등 데이터 구축에 필요한 요구사항
- 테스트 요구사항 : 장비의 성능 테스트나 구축된 시스템 테스트 및 점검하기 위한 테스트 요구사항
- 보안 요구사항 : 시스템의 데이터 및 기능, 운영 접근을 통제하기 위한 요구사항
- 품질 요구사항 : 관리가 필요한 품질 항목, 품질 평가 대상에 대한 요구사항, 가용성, 정합성, 상호 호환성, 대응성, 신뢰성, 사용성, 유지관리성, 이식성, 확장성, 보안성 등으로 구분하여 기술
- 제약사항 : 시스템 설계, 구축, 운영과 관련하여 사전에 파악된 기술, 표준, 업무, 법제도등의 제약조건
- 프로젝트 관리 요구사항 : 원활한 수행을 위한 관리 방법
- 프로젝트 지원 요구사항 : 프로젝트의 원활한 수행을 위한 지원 사항이나 방안

<br>

**3. 사용자 요구사항(User requirements)**   
- 사용자 관점에서 본 시스템이 제공해야 할 요구사항
- 사용자를 위한 것으로 친숙한 표현으로 이해하기 쉽게 작성


<br>

**4. 시스템 요구사항**   
- 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항
- 소프트웨어 요구사항이라고 함.

<br>

### 3.2 요구사항 개발 프로세스
> 도출 > 분석 > 명세 > 확인 

<br>

**1. 요구사항 도출(Requirement Elicitation)**   
- 시스템, 사용자, 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 도출해 내는 첫번째 단계
- 주요 기법은 청취와 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 등이 있다

<br>

**2. 요구사항 분석(Requirement Analysis)**   
- 소프트웨어의 실제적인 첫 단계로 개발 대상에 대한 사용자의 요구사항을 이해하고 명세화 하는 활동
- 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 안흔 부분을 발견하고 이를 걸러내기 위한 과정
- 사용자 요구사항의 **타당성 조사 및 비용, 일정에 대한 제약** 설정
- 중복되거나 상충되는 요구사항들을 중재하는 과정
- 도출된 요구사항들을 쇼프트웨어 범위 파악 및 주변 환경이 상호 작용하는 방법을 이해
- 구조적 분석 기법은 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법으로, 다음과 같은 특징이 있다.
  - 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항 파악 및 문서화 함
  - 하향식 방법을 사용하여 시스템을 세분화 하고, 중복을 배제할 수 있다.
  - 시스템 분석의 질이 향상되고, 시스템 개발의 모든 단계에서 필요한 명세서 작성이 가능
- 자료 흐름도(DFD), 자로사전(DD), 소단위 명세서(Mini-Spec), 개체관계도(ERD), 상태 전이도(STD) 등의 도구 사용

<br>

**2-1. 자료 흐름도(DFD; Data Flow Diagram)**
- 자료의 흐름  및 변환 과정과 기능을 도형 중심으로 기술하는 방법
- 자료 흐름 그래프, 버블 차트라고도 함.
- 구조적 분석 기법에 이용됨
- 자료의 흐름과 기능을 4가지 기본 기호로 표시함   
<br><img src="https://t1.daumcdn.net/cfile/tistory/21513842570C3F6339"><br>

**2-2. 자료 사전(DD; Data Dictionary)**
- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것
- 메타 데이터라고도 함   
<br><img src="https://t1.daumcdn.net/cfile/tistory/2258E840570C401032"><br>

**2-3. 소단위 명세서(Mini-Spec.)**
- 자료 흐름도 상의 최하위 처리 절자를 상세하게 기술하는데 사용하는 도구
- 프로세스 명세서 라고도 함

**2-4. 개체 관계도(ERD; Entity Relationship Diagram)**
- 시스템에서 처리되는 개체(자료)와 개체의 구성과 속성, 개체 간의 관계를 표현하여 개체를 모델화하는 도구
- 개체(Entity), 관계(Relationship), 속서(Attribute) 등이 있음

**2-5. 상태 전이도(STD; State Transition Diagram)**
- 시스템의 상태와 상태의 변화를 모델링하는 것
- 상태 전이도를 통해 개발자는 시스템의 행위를 정의할 수 있음
  
<br>

**3. 요구사항 명세(Requirement Specification)**   
- 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것
- 문서화할 때는 기능 요구사항은 빠짐없이 완전하고 명확하게 해야 하며, 비기능 요구사항은 필요한 것만 명확하게 기술
- 사용자가 이애하기 쉬우며, 개발자가 효과적으로 설계할 수 있도록 작성 (관찰 및 모델 작성 기술)
- 구체적인 명세를 위해 소단위 명세서가 사용될수 있다.

<br>

**4. 요구사항 확인(Requirement Validation, 요구사항 검증)**   
- 요구사항 명세서가 정확하고 안전하게 작성되었는지를 검토
- 개발이 완료된 후 문제가 발견되면 재작업 비용이 발생할 수 있어 꼼꼼한 검증 필요
- 명세서의 내용이 이해하기 쉬운지, 일관성, 회사의 기준, 누락된 기능은 없는지 등을 검증하는 것이 중요

<br>

# 4 요구사항 분석 CASE와 HIPO

### 4.1 요구사항 분석을 위한 CASE(자동화 도구)
- 표준화와 보고를 통한 문서화 품질 개선
- 데이터 베이스가 모두에게 이용 가능하다는 점에서 분석자들 간의 적절한 조정
- 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성
- 변경이 주는 영향 추적의 용이성
- 명세에 대한 유지보수 비용의 축소

<br>

### 4.2 자동화 도구 종류
- **SADT(Structured Analysis and Design Technique)**
  - SoftTech 사에서 개발
  - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구

- **SREM(Software Requirements Engineering Methodology) = RSL/REVS**
  - TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발
  - RSL / REVS를 사용하는 자동화 도구
    - `RSL (REquirement Statement Language)` : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어
      - 요소 : 요구사항 명세를 개발하기 위해 사용되는 개체와 개념
      - 속성 : 요소를 수정하거나 수식하기 위한 것
      - 관계 : 개체들 간의 관계
      - 구조 : 정보 흐름을 묘사하기 위한 것
    - `REVS(Requirement Engineering and Validation System)` : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기

- **PSL(Problem Statement Language) / PSA(Problem Statement Analyzer)**
  - 미시간 대학에서 개발한 것으로 PSL, PSA를 사용하는 자동화 도구
    - PSL : 문제(요구사항) 기술언어
    - PSA : PSL로 기술한 요구사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기

- **TAGS(Technology for Automated Generation of Systems)**
  - 시스템 공학 방법 응용에 대한 자동 접근 방법으로, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구
  - 구성 : IORL, 요구사항 분석과 IORL 처리를 위한 도구
  - IORL : 요구사항 명세 언어

<br>

### 4.3 HIPO
- 시스템의 분석 및 설계나 문서화할 때 사용되는 기법
- 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타냄
- 체계적인 문서관리 가능
- 기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉬움
- 변경, 유지보수가 용이
- 기능과 자료의 의존 관계 동시 표현 가능
- `HIPO Chart` : 시스템 기능 여러개의 고유 모듈들로 분할 하여 이들 간의 인터페이스를 계층구조로 표현한 것

<br>

### 4.4 HIPO Chart의 종류
- 가시적 도표(Visula Table of Contents / 도식목차) : 전첵적인 기능과 흐름을 보여주는 계층(Tree) 구조도
- 총체적 도표(Overview Diagram / 총괄도표, 개요도표) : 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표
- 세부적 도표(Detail Diagram / 상세 도표) : 기본 요소들을 상세히 기술하는 도표


<br>


# 5. UML (Unified Modeling Language)

UML은 시스템 분석, 설계 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
UML의 구성요소에는 사물(Things), 관계(Relationships), 다이어그램(Diagram) 등이 있다.

<br>

### 5.1 사물(Things)
- 모델을 구성하는 가장 중요한 기본 요소, 다이어그램 안에서 관계가 형성될 수 있는 대상
- 구조사물(Structural Things) : 시스템의 개념적, 물리적 요소를 표현 (Class, Use Case, Component, Node 등)
- 행동사물(Behavioral Things) : 시간과 공간에 따른 요소들의 행위를 표현 (Interaction, State Machine 등)
- 그룹사물(Grouping Things) : 요소들을 그룹으로 묶어서 표현 (Package)
- 주해사물(Annotation Things) : 부가적인 설명이나 제약조건 등을 표현 (Note)

<br>

### 5.2 관계(Relationships)
- 사물 사이의 연관성을 표현하는 것
- 연관, 집합, 포함, 일반화, 의존, 실체화 관계등이 있다.
  
- **연관(Association)관계**
  - 2개 이상의 사물이 서로 관련되어 있음을 표현
  - 사물 사이를 실선으로 연결하여 표현, 방향성은 화살표로 표현
  - 양방향 관계의 경우 화살표 생략, 실선으로만 연결
  - 객체의 개수를 의미하는 다중도(Multiplictity)를 선 위에 표기

|다중도|의미|
|:---|:---|
|1|1개의 객체가 연관|
|n|n개의 객체가 연관|
|0..1|연관된 객체가 없거나 1개만 존재|
|0..* 또는 *|연관된 객체가 없거나 다수일 수 있다|
|1..*|연관된 객체가 적어도 1개 이상|
|n..*|연관된 객체가 적어도 n개 이상|
|n..m|연관된 객체가 최소 n개에서 최대 m개|

- **집합(Aggregation)관계**
  - 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현

- **포함(Composition)관계**
  - 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계를 표현

- **일반화(Generalization)관계**
  - 하나의 사물이 다른 사물에 비해 더 일반적인지를 구체적인지를 표현

- **의존(Dependency)관계**
  - 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현

- **실체화(Realization)관계**
  - 사물이 할 수 있거나 해야하는 기능(오퍼레이션, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현
  

<br><img src="https://www.nextree.co.kr/content/images/2021/01/--6-----------.png" style="width:500px; height:auto;"><br>



<br>

### 5.3 다이어그램(Diagram)
- 사물과 관계를 도형으로 표현한 것

- 정적 모델링에서는 주로 `구조적 다이어그램` 사용, 동적 모델링에서는 `행위 다이어그램`을 사용 함

- **구조적(Structural) 다이어그램의 종류**
  - **클래스 다이어그램(Class Diagram)**
    - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계 표현
    - 시스템의 구조를 파악하고 구조상 문제점을 도출할 수 있다.
    - 시스템을 모델링하는데 자주 사용
    - 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램
    - 시스템 구성 요소를 문서화하는데 사용
    - 클래스 다이어그램의 구성요소는 클래스,제약조건,관계 등으로 구성됨

      - 클래스(Class)
        - 클래스는 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현
        - 3개의 구획(Compartment)으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기
        - 속성(Attribute) => 클래스의 상태나 정보 표현
        - 오퍼레이션(Operation) => 함수(메소드,Method)

      - 제약조건 
        - 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적음

      - 관계(Relationship)
        - 관계는 클래스와 클래스 사이의 연관성을 표현
        - 연관,집합,포함,일반화,의존 관계가 있음

  - **객체 다이어그램(Object Diagram)**  
    - 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현
    - 럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델링에 활용

  - **컴포넌트 다이어그램(Component)**
    - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
    - 구현 단계에서 사용되는 다이어그램

  - **배치 다이어그램(Deployment Diagram)**
    - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
    - 구현 단계에서 사용되는 다이어그램

  - **복합체 구조 다이어그램(composite Structure Diagram)**
    - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현

  - **패키지 다이어그램(Package Diagram)**
    - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현

    <br>
  
- **행위(Behavioral) 다이어그램의 종류**
  - **유스케이스 다이어그램(Use Case Diagram)**
    - 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
    - 외부 요소와 시스템 간의 상호 작용을 확인
    - 사용자의 요구사항을 분석하기 위한 도구로 사용
    - 시스템의 범위를 파악 할 수 있음
    - 시스템 범위, 액터 유스케이스, 관계로 구성됨

      - 시스템 범위(System Scope) 
        - 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현
  
      - 액터(Actor) 
        - 시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미
        - 주액터 : 시스템을 사용함을로써 이득을 얻는 대상으로 주로 사람이 해당
        - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관등이 될 수 있음

      - 유스케이스(Use Case)
        - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것

      - 관계(Relationship)
        - 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있음
        - 포함관계, 확장관계, 일반화 관계의 3종류가 잇음

  - **시퀸스 다이어그램(Sequence Diagram)**
    - 상호 작용하는 시스템이나 객체들이 주고 받는 메시지를 표현
    - 동작에 참여하는 시스템이나 객체들의 수행 기간 확인 가능
    - 객체들을 기본단위로 하여 그들의 상호작용을 표현
    - 유스케이스 명세서를 하나의 표현 범위로 하지만, 하나의 클래스에 포함된 오퍼레이션을 하나의 범위로 표현하기도 함
    - 액터, 객체, 생명선, 실행, 메시지 등으로 구성

      - 액터(Actor)
        - 시스템으로 부터 서비스를 요청하는 외부 요소
        - 사람이나 외부 시스템을 의미

      - 객체(Object)
        - 메시지를 주고받는 주체

      - 생명선(Lifeline)
        - 객체가 메모리에 존재하는 기간
        - 객체 아래쪽에 점선을 그어 표현

      - 실행상자(Active Box)
        - 객체가 메시지를 주고받으며 구동되고 있음을 표현함

      - 메시지(Message)
        - 객체가 상호 작용을 위해 주고받는 메시지
  
  - **커뮤니케이션 다이어그램(communication Diagram)**
    - 시퀸스 다이어그램과 같이 동작에 참여하는 객체들이 주고 받는 메시지를 표현
    - 객체들 간의 연관까지 표현
  - **상태 다이어그램(State Diagram)**
    - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변환하는지를 표현
    - 럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용
  - **활동 다이어그램(Activity Diagram)**
    - 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
  - **상호작용 개요 다이어그램(Interaction Overview Diagram)**
    - 상호작용 다이어그램 간의 제어 흐름을 표현
  - **타이밍 다이어그램(Timing Diagram)**
    - 객체 상태 변화와 시간 제약을 명시적으로 표현


<br>

# 6.아키텍처 패턴

- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
- 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙,지침 등이 포함
- 아키텍처 스타일 또는 표준 아키텍처라고도 함
- 아키텍처 패턴의 장점

  - 시행착오를 줄여 개발시간 단축, 고품질의 소프트웨어를 생산
  - 검증된 구조로 개발하기 때문에 안정적인 개발이 가능
  - 의사소통이 간편하다.
  - 시스템 구조를 이해하는 것이 쉬워 개발에 참여하지 않아도 유지보수를 수행할 수 있음
  - 시스템의 특성을 개발 전에 예측하는 것이 가능

- 아키텍처 패턴의 종류는 `레이어 패턴`, `클라이언트-서버 패턴`, `파이프-필터 패턴`, `모델-뷰-컨트롤러 패턴` 등이 있음

<br>

### 6.1 레이어 패턴(Layers pattern)
- 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법중 하나
- 서로 마주보는 두 개의 계층 사이에서만 상호작용으로 변경 작업이 용이
- 특정 계층만을 교체해 시스템을 개선하는 것이 가능
- 대표적으로 OSI 참조모델이 있다.
  
<br>

### 6.2 클라이언트-서버 패턴(Client-Server Pattern)
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
- 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지
- 클라이언트나 서버는 요청과 응답을 받기 위해 동기화 되는 경우를 제외하고는 서로 독립적
 
<br>

### 6.3 파이프-필터 패턴(Pipe-Fiter Pattern)
- 데이터 스트림절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이프(Pipe)를 통해 데이터를 전송하는 패턴
- 재사용성이 좋고, 추가가 쉬워 확장이 용이하다
- 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축 가능
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용
- 데이터 변환으로 인한 오버헤드가 발생
- 대표적으로 UNIX의 쉘(Shell)이 있다.
  
<br>

### 6.4 MVC 패턴(Model-View-Controller Pattern)
- 서브시스템을 3개의 부분으로 구조화하는 패턴
- 모델(Model) : 서브시스템의 핵심 기능과 데이터를 보관
- 뷰(View) : 사용자에게 정보를 표시
- 컨트롤러(Controller) : 사용자로부터 받은 입력을 처리
- 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발작업을 수행
- 여러개의 뷰를 만들수 잇어 대화형 애플리케이션에 적합
  
<br>

### 6.5 기타패턴
- 마스터-슬레이브 패턴(Master-Slave Pattern) 
  - 동일한 구조의 슬레이브 컴포넌트로 작업을 분할한 후, 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴
  - 장애 허용 시스템, 병렬 컴퓨팅 시스템에서 주로 활용

- 브로커 패턴(Broker Pattern)
  - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 요청에 맞는 컴포넌트 사용자와 연결
  - 원격 서비스 호출에 응답하는 컴포넌트들이 여러개 있을 대 적합한 패턴
  - 분산 환경 시스템에서 주로 활용

- 피어-투-피어 패턴(Pear-To-Pear Pattern)
  - 피어(Pear)를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
  - 클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용

- 이벤트-버스 패턴(Event-Bus Pattern)
  - 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식

- 블랙보드 패턴(Blackboard Pattern)
  - 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있음.
  - 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴
  - 음성인식, 차량식별, 신호해석등에 주로 활용

- 인터프리터 패턴(Interpreter Pattern)
  - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도로 구성

<br>

# 7. 객체지향(Object-Oriented)
- 객체들을 조립해서 작성할 수 있는 기법
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용
- 재사용 및 확장이 용이하고 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.
- 복잡한 구조를 단계적,계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리를 지원
- 현실 세계를 모형화하므로 사용자와 개발자가 쉽게 이해함
  
<br>

### 7.1 객체(Object)
- 데이터와 데이터를 처리하는 함수를 묶어 놓은 (캡슐화한) 하나의 소프트웨어 모듈
- 데이터 => 객체가 가지고 있는 정보로 속성아나 상태, 분류등을 나타냄
- 함수 => 객체가 수행하는 기능으로 객체가 갖는 데이터(속성,상태)를 처리하는 알고리즘 

<br>

### 7.2 클래스(Class)
- 공통된 속성과 연산(행위)을 갖는 객체의 집합
- 객체들이 갖는 속성과 연산을 정희하고 있는 틀
- 데이터를 추상화하는 단위
- 클래스에 속한 각각의 객체를 인스턴스(Instance)라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 함

<br>

### 7.3 캡슐화(Encapsulation)
- 데이터(속성)와 테이터를 처리하는 함수를 하나로 묶는 것을 의미
- 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적음
- 재사용이 용이하고, 인터페이스가 단순해지고, 객체간의 결합도가 낮음

<br>

### 7.4 상속(Inheritance)
- 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 안하도 자신의 속성으로 사용 가능
- 소프트웨어의 재사용(Reuse)을 높이는 중요한 개념
- **다중상속(Multiple Inheritance)** : 한 개의 클래스가 두 개 이상의 상위 클래스로 부터 속성과 연산을 상속받는것 

<br>

### 7.5 다형성(Polymorphism)
- 객체가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미
- 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답
- 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것
  
<br>

### 7.6 연광성(Relationship)
- 연관성은 두 개 이상의 객체(클래스)들이 상호 참조하는 관계
  
|종류|의미|특징|
|:---|:---|:---|
|is member of|연관화(Association)|2개 이상의 객체가 상호 관련되어 있을을 의미|
|is instance of|분류화(Classfication)|동일한 형의 특성을 갖는 객체들을 모아 구성하는 것|
|is part of|집단화(Agregation)|관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것|
|is a|일반화(Generaliztion)<br>특수화/상세화(Specialization)|공통적인 성질들로 추상화한 상위 객체를 구성<br>상위 객체를 구체화하여 하위 객체를 구성|

<br>

# 8. 객체지향 분석 및 설계
- 객체지향 분석(OOA; Object Oriented Analysis)은 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간의 관계등을 정의하여 모델링하는 작업
- 객체와 속성, 클래스와 멤버, 전체와 부분등으로 나누어 분석
- 분석가에게 주요한 모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화할 수 있게 해줌
- 객체는 클래스로부터 인스턴스화되고, 이 클래스를 식별하는 것이 객체지향 분석의 주요한 목적
 
<br>

### 8.1 객체지향 분석의 방법론

- **Rumbaugh(럼바우) 방법**
  - 가장 일반적으로 사용되는 방법
  - 분석활동을 객체,동적,기능 모델로 나누어 수행

- **Booch(부치) 방법**
  - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법
  - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의

- **Jacobson 방법**
  - Use Case를 강조하여 사용하는 분석 방법

- **Coad와 Yourdon 방법**
  - E-R 다이어그램을 사용하여 객체의 행위 모델링
  - 객체식별,구조식별,주제정의,속성과 인스턴스 연결정의, 연산과 메시지 연결정의 등의 과정으로 구성하는 기법

- **Wirfs-Brock 방법**
  - 분석과 설계간의 구분이 없음
  - 고객 명세서를 평가해서 설계작업까지 연속적으로 수행하는 기법

<br>

### 8.2 럼바우(Rumbaugh)의 분석 기법
- 객체 모델링 기법(OMT, Object-Modeling Technique)이라고도 함
- 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링 하는 기법

  - **객체모델링(Object Modeling)**
    - `정보 모델링` 이라고도 함
    - 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 `객체 다이어그램`으로 표시하는 것

  - **동적모델링(Dynamic Modeling)**
    - `상태 다이어그램`을 이용
    - `시간의 흐름`에 따른 객체들 간의 제어흐름,상호작용,동작순서 등의 동적인 행위를 표현하는 모델링

  - **기능모델링(Functional Modeling)**
    - `자료 흐름도(DFD)`를 이용
    - 다수의 프로세스들 간의 `자료 흐름`을 중심으로 처리 과정을 표현한 모델링

<br>

### 8.3 객체지향 설계 원칙
- 시스템 변경이나 확장에 유연한 시스템을 설꼐하기 위해 지켜야 할 다섯가지 원칙
- SOLID 원칙이라고도 불린다

  - **단일 책임 원칙(`S`RP, Single Responsibility Principle)**
    - `객체는 단 하나의 책임`만 가져야 한다.
    - 응집도는 높고 결합도는 낮게 설계

  - **개방-폐쇄 원칙(`O`CP, Open-Closed Principle)**
    - 기존 코드 변경 X , 기능을 추가 할 수 있도록 설계
    - 공통 인터페이스를 하나의 인터페이스로 묶어 `캡슐화` 하는 방법이 대표적

  - **리스코프 치환 원칙(`L`SP, Liskov Substitution Principle)**
    - `자식`클래스는 최소한 자신의 `부모` 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
    - 자식은 부모의 책임을 부무시하거나 재정의하지 않고 확장만 수행하도록 해야함

  - **인터페이스 분리 원칙(`I`SP, Interface Segregation Principle)**
    - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
    - `인터페이스`가 갖는 하나의 책임

  - **의존 역전 원치(`D`IP,Dependency Inversion Principle)**
    - `추상성`이 낮은 클래스 보다 추상성이 높은 클래스와 `의존 관계`를 맺어야 한다는 원칙
    - 일반적으로 인터페이스를 활용하면 이 원칙은 준수됨.

<br>

# 9. 디자인 패턴(Design Pattern)
- 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
- 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
- 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징
- GoF의 디자인 패턴은 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴이다.
- GoF의 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성

<br>

### 9.1 아키텍처 패턴 vs 디자인 패턴
- 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설꼐에 사용
- 아티텍처 패턴은 전체 시스템의 구조를 설계하기 위한 참조모델 vs 디자인패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
- 몇몇 디자인 패턴은 특정 아키텍처 패턴을 구현하는데 유용하게 사용

<br>

### 9.2 디자인 패턴 사용의 장,단점
- 범용적인 코딩 스타일로 인해 구조 파악이 용이
- 객체지향 설계 및 구현의 생산성을 높이는데 적합
- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약
- 초기 투자 비용이 부담될 수 있음 (단, 전체적으로 보면 절약될 수 있음)
- 개발자 간의 원활한 의사소통이 가능
- 설계 변경 요청에 대한 유연한 대처가 가능
- 객체지향 기반 이외 다른 기반 개발에는 적합하지 않음


<br>

### 9.3 생성 패턴(Creational Pattern)
- 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램의 유연성을 더해줌
  - **추상 팩토리(Abstract Factory)**
    - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연과느의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
    - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능

  - **빌더(Builder)**
    - 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성
    - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들수 잇음

  - **팩토리 메소드(factory Method)**
    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
    - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브클래스가 담당
    - 가상 생성자 (Virtual Constructor) 패턴 이라고도 함

  - **프로토타입(Prototype)**
    - 원본 객체를 복제하는 방법
    - 객체를 생성하는 패턴
    - 일반적인 방법으로 객체를 생성하여, 비용이 큰 경우 주로 이용

  - **싱글톤(Singleton)**
    - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
    - 클래스 내에서 인스턴스가 하나뿐임을 보장하여, 불필요한 메모리 낭비를 최소화 할 수 있음

<br>

### 9.4 구조 패턴(Structural Pattern)
- 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
- 구조가 복잡한 시스템을 개발하기 쉽게 도와줌
  - **어댑터(Adapter)**
    - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
    - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용

  - **브리지(Bridge)**
    - 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
    - 기능과 구현을 두 개의 별도 클래스로 구현

  - **컴포지트(Composite)**
    - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
    - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현

  - **데코레이터(Decorator)**
    - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
    - 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현

  - **퍼싸드(Facade)**
    - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
    - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요

  - **플라이웨이트(Flyweight)**
    - 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
    - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용

  - **프록시(Proxy)**
    - 접근이 어려운 객체와 여기에 연결하려는 객체사이에서 인터페이스 역할을 수행하는 패턴
    - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용

<br>

### 9.5 행위 패턴(Behavioral Pattern)
- 클래스나 객체들이 서로 상호작용하는 방법이나, 책임 분배 방법을 정희하는 패턴
- 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와줌
  - **책임 연쇄(Chain of Responsibility)**
    - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
    - 요청을 처리할 수 잇는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감.

  - **커맨드(Command)**
    - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
    - 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화

  - **인터프리터(Interpreter)**
    - 언어에 문법 표현을 정의하는 패턴
    - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용

  - **반복자(Iterator)**
    - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
    - 내부 표현 방법의 노출 없이 순차적인 접근이 가능

  - **중재자(Mediator)**
    - 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
    - 객체 사이의 의존성을 줄여 결합도를 감소시킴
    - 중재자는 객체 간의 통제와 지시의 역할을 수행

  - **메멘토(Memento)**
    - 특정 시점에서의 객체 내부 상태를 객체화함을로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
    - Ctrl+Z와 같은 되돌리기 기능을 개발할 때 주로 이용.

  - **옵서버(Ovserver)**
    - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
    - 주로 분산된 시스템 간에 이벤트를 생성,발행(Pubish)하고, 이를 수신(Subscribe)해야 할 때 이용

  - **상태(State)**
    - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
    - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리

  - **전략(Strategy)**
    - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
    - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있음
    - 클리이언트에 영향 없이 알고리즘의 변경이 가능

  - **템플릿 메소드(Template Method)**
    - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
    - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌

  - **방문자(Visitor)**
    - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
    - 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행

