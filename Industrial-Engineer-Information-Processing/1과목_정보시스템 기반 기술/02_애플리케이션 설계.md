# 1.소프트웨어 생명 주기 (Software Life Cycle) 및 모형

소프트웨어 생명주기는 소프트웨어 개발 방법론의 바탕이 되는 것으로, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것이다.
- 소프트웨어 수명주기라고도 함
- 소프트웨어 프로세스 모형 또는 소프트웨어 공학 패러다임이라고 함
- 소프트웨어 생명 주기 모형에는 폭포수 모형, 프로토타임 모형, 나선형 모형, 애자일 모형 등이 있음

<br>

### 1.1 소프트웨어 공학의 개념
- 소프트웨어 공학(SE; Software Engineering)은 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문, 여러가지 방법론과 도구, 관리 기법들이 통하여 소프트웨어의 품질과 생산성을 향상시킬 목적
  - IEEE의 소프트웨어 공학 표준 용어사전 : 소프트웨어의 개발, 운용, 유지보스, 폐기 처분에 대한 체계적인 접근 방안
  - Fairley : 지정된 비용과 기간 내에 소프트웨어를 체계적으로 생산하고 유지 보수 하는데 관련된 기술적이고 관리적인 원리
  - Boehm : 과학적인 지식을 소프트웨어 설계과 제작에 응용하는 것이며 이를 개발, 운용, 유지보수하는데 필요한 문서 작성 과정

- 기본 원칙
  - 현대적인 프로그램밍 기술을 계속적으로 적용 (update)
  - 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증 (유지보수)
  - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지 (기록)

<br>

### 1.2 폭포수 모형(Waterfall Model)
- 각 단계를 철처하게 검토하여 승인 과정을 거친 후에 다음단계를 진행하는 개발 방법론
- 소프트웨어 공학에서 가장 오래되고 폭넑게 사용된 전독적인 소프트웨어 생명주기 모형
- 개발 과정의 한 단계가 끝나야만 다음 단계로 넘어갈 수 있는 선형 순차적 모형
- 모형을 적용한 경험과 성공 사례가 많음
- 두 개 이상의 과정이 병행하여 수행되지 않는다.   
<br><img src="https://images.velog.io/images/arittung/post/056810d7-3a43-45ba-9537-8683083de5cf/image.png"><br>

<br>

### 1.3 프로토타입 모형(Prototype Model, 원형 모형)
-  실제 개발될 소프트웨어에 대한 견본(시제)품(Prototype)을 만들어 최종 결과물을 예측하는 모형
- 시제품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발
- 시스템 또는 모형을 만들면서 구현된 소프트웨어를 추후 구현단계에서 사용될 골격 코드가 된다.
- 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보완하기 위한 모형   
<br><img src="https://images.velog.io/images/arittung/post/9610ddef-7674-42cd-8bbd-08ebfb4735e8/image.png"><br>

<br>

### 1.4 나선형 모형(Spiral Model, 점진적 모형)
- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 소프트웨어 개발 시 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적
- 누락되거나 추가된 요구사항을 첨가할 수 있고, 정밀하며, 유지보수 과정이 필요 없다.
- 점진적 모형이라고 함
  - 점진적 모형이란 나선을 따라 돌듯이 여러번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 만들어 내는 것

<br><img src="https://images.velog.io/images/arittung/post/5f1ba257-9ebb-454d-a6c9-1f79d83c540d/image.png">

<br>

### 1.5 애자일 모형(Agile Model)
- 고객의 요구사항 변화에 유연하게 대응할 수 있또록 일정한 주기를 반복하면서 개발과정 진행
- 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭
- 기업 활동 전반에 걸쳐 사용
- 스프린트(Sprint)  또는 이터레이션(Iteration)이라고 불리는 짧은 개발 주기를 반복하며, 반복되는 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구를 적극 수용
- 소규모 프로젝트, 고도로 숙달된 개발자, 급현하는 요구사항에 적합
- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형
  - 스크럼(Scrum)
  - XP(eXtreme Programming)
  - 칸반(Kanban)
  - Lean
  - 크리스탈(Crystal)
  - ASD(Adaptive Software Development)
  - FDD(Feature Driven Development) 기능 중심 개발
  - DSDM(Dynamic System Development Method)
  - DAD(Disciplined Agile Delivery)  - 

<br><img src="https://images.velog.io/images/arittung/post/d939149d-50f0-49f4-9ca0-d95654d1c79c/image.png">

<br>

### 1.6 애자일 개발 4가지 핵심 가치
1. 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
2. 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
3. 계약 협상보다는 고객과 협업에 더 가치를 둔다.
4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다

<br>

### 1.7 애자일 개발 12가지 실행 지침
1. 유용한 소프트웨어를 빠르고, 지속적으로 제공하여 고객을 만족시킨다.
2. 개발 막바지라도 요구사항 변경을 적극 수용한다
3. 몇 개월이 아닌 몇 주 단위로 실행되는 소프트웨어를 제공한다
4. 고객과 개발자가 프로젝트 기간에 함께 일한다.
5. 개발에 대한 참여 의지가 확실한 사람들로 팀을 구성하고, 필요한 개발 환경과 지원을 제공하며, 일을 잘 끝낼 수 있도록 신뢰한다.
6. 같은 사무실에서 얼굴을 맞대고 의견을 나눈다.
7. 개발의 진척도를 확인하는 1차 기준은 작동하는 소프트웨어이다.
8. 지속 가능한 개발을 장려하고 일정한 속도로 개발을 진행한다.
9. 기술적 우수성과 좋은 설계에 지속적인 관심을 기울이면 미첩성이 향상된다.
10. 단순화를 추구한다.
11. 최상의 아키텍처, 명확한 요구사항, 최상의 설계는 자기 스스로 일을 주도하는 조직적인 팀으로부터 나온다
12. 더 효과적인 팀이 될 수 있는 방안을 정기적으로 깊이 고민하고 그에 따라 팀의 행동을 조정한다.

<br>

### 1.8 폭포수 모형과 애자일의 비교
|구분|폭포수 모형|애자일|
|:---|:---|:---|
|새로운 요구사항 반영|어려움|지속적으로 반영|
|고객과의 의사소통|적음|지속적임|
|테스트|마지막에 모든 기능을 테스트|반복되는 일정 주기가 끝날 때마다 테스트|
|개발 중심|계획, 문서(메뉴얼)|고객|

<br>

# 2. 소프트웨어 개발 방법론

소프트웨어 개발, 유지보수 등에 필요한 여러가지 일들의 수행 방법 및 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것
- 소프트웨어의 생산성과 품질 향상이 목적
- 종류에는 구조적 , 정보공학, 객체지향, 컴포넌트 기반(CBD), 애자일, 제품 계열 방법론 등

<br>

### 2.1 구조적 방법론
- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 **문서화하는 처리중심 방법론**
- 1960년대 까지 가장 많이 사용
- 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적
- 복잡한 문제를 다루기 위해 분과 정복(Divide and Conquer)원리를 적용
  
    >**구조적 방법론의 절차**   
    > 타당성 검토 > 계획 > 요구사항 > 설계 > 구현 > 시험 > 운용/유지보수

<br>

### 2.2 정보공학 방법론
- 정형화된 기법들을 상호 연광성 있게 통합 및 적용하는 **자료(Data)중심의 방법론**
- 대규모 정보 시스템을 구축하는데 적합
  
    >**정보공학 방법론의 절차**   
    > 정보 전략 계획 수립 > 업무 영역 분석 > 업무 시스템 설계 > 업무 시스템 구축

<br>

### 2.3 객체지향 방법론
- 기계의 부품을 조립하듯이 **객체(Object)들을 조립**해서 필요한 소프트웨어를 구현하는 방법론
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책
- 구성요소 => 객체(Object), 클래스(Class), 메시지(Message) 등
- 기본원칙 => 캡슐화(Encapsulation), 정보은닉(Information Hiding), 추상화(Abstraction), 상속성(Inheritance), 다형성(Polymorphism) 등

    >**객체지향 방법론의 절차**   
    >요구분석 > 설계 > 구현 > 테스트 및 검증 > 인도

<br>

### 2.4 컴포넌트 기반(CBD; Component Based Design) 방법론
- 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
- 컴포넌트란 문서, 소스코드, 파일, 라이브러리 등과 같은 모듈화된 자원
- `재사용(Reusability)`이 가능하여 시간과 노력을 절감
- **확장성이 보장, 유지 보수 비용을 최소화, 생산성 및 품질 향상**

    >**컴포넌트 기반 방법론의 절차**   
    > 개발준비 > 분석 > 설계 > 구현 > 테스트 > 전개 > 인도

<br>

### 2.5 애자일(Agile) 방법론
- 일정한 주기를 반복하면서 개발 과정을 진행하는 방법론
- 소규모 프로젝트, 고도로 숙달된 개발자, 급현하는 요구사항에 적합
- 대죠적인 종류 => 익스트림 프로그래밍(XP), 스크럼(Scrum), 칸반(Kanban), 크리스탈(Crytal) 등

    >**애자일 방법론의 절차**   
    >사용자 스토리 > [계획 > 개발 > 승인테스트]  []구간 반복

<br>

### 2.6 제품 계열 방법론
- 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
- 임베디드 소프트웨어를 만드는데 적합

<br>

# 3. 요구사항 정의

- 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건 등을 나타냄
- 요구사항이 제대로 정의되어야만 목표와 계획을 수립할 수 있다.
- 요구사항은 소프트웨어 개발 의뢰자, 개발자, 사용자 등 간의 의사소통을 원활하게 하는데 도움을 준다.


### 3.1 요구사항의 유형

일반적으로 기술하는 내용에 따라 `기능 요구사항` or `비기능 요구사항`으로 구분하며, 기술관점과 대상의 범위에 따란 `시스템 요구사항` or `사용자 요구사항`으로 나눈다.   

<br>

**1. 기능 요구사항 (Functional requirements)**   
- 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
- 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 지장하거나 연산을 수행해야 하는지에 대한 사항
- 시스템이 반드시 수행해야 하는 기능
- 사용자가 시스템을 통해 제공받기를 원하는 기능

<br>

**2. 비기능 요구사항(Non-functional requirements)**   
- 시스템 장비 구성 요구사항 : 하드웨어, 소프트웨어, 네트워크 등의 시스템 장비구성에 대한 요구사항
- 성능 요구사항 : 처리 속도 및 시간 처리량, 동적,정적 적용량, 가용성 등 성능에 대한 요구사항
- 인터페이스 요구사항 : 시스템 <ㅡ> 사용자 인터페이스, 하드웨어 및 통신 인터페이스, 정보교환에 사용되는 프로토콜과의 연계도 포함하여 기술
- 데이터 요구사항 : 초기 자료 구축 및 데이터 변환을 위한 대상, 방법, 보안이 필요한 데이터등 데이터 구축에 필요한 요구사항
- 테스트 요구사항 : 장비의 성능 테스트나 구축된 시스템 테스트 및 점검하기 위한 테스트 요구사항
- 보안 요구사항 : 시스템의 데이터 및 기능, 운영 접근을 통제하기 위한 요구사항
- 품질 요구사항 : 관리가 필요한 품질 항목, 품질 평가 대상에 대한 요구사항, 가용성, 정합성, 상호 호환성, 대응성, 신뢰성, 사용성, 유지관리성, 이식성, 확장성, 보안성 등으로 구분하여 기술
- 제약사항 : 시스템 설계, 구축, 운영과 관련하여 사전에 파악된 기술, 표준, 업무, 법제도등의 제약조건
- 프로젝트 관리 요구사항 : 원활한 수행을 위한 관리 방법
- 프로젝트 지원 요구사항 : 프로젝트의 원활한 수행을 위한 지원 사항이나 방안

<br>

**3. 사용자 요구사항(User requirements)**   
- 사용자 관점에서 본 시스템이 제공해야 할 요구사항
- 사용자를 위한 것으로 친숙한 표현으로 이해하기 쉽게 작성


<br>

**4. 시스템 요구사항**   
- 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항
- 소프트웨어 요구사항이라고 함.

<br>

### 3.2 요구사항 개발 프로세스
> 도출 > 분석 > 명세 > 확인 

<br>

**1. 요구사항 도출(Requirement Elicitation)**   
- 시스템, 사용자, 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 도출해 내는 첫번째 단계
- 주요 기법은 청취와 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 등이 있다

<br>

**2. 요구사항 분석(Requirement Analysis)**   
- 소프트웨어의 실제적인 첫 단계로 개발 대상에 대한 사용자의 요구사항을 이해하고 명세화 하는 활동
- 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 안흔 부분을 발견하고 이를 걸러내기 위한 과정
- 사용자 요구사항의 **타당성 조사 및 비용, 일정에 대한 제약** 설정
- 중복되거나 상충되는 요구사항들을 중재하는 과정
- 도출된 요구사항들을 쇼프트웨어 범위 파악 및 주변 환경이 상호 작용하는 방법을 이해
- 구조적 분석 기법은 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법으로, 다음과 같은 특징이 있다.
  - 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항 파악 및 문서화 함
  - 하향식 방법을 사용하여 시스템을 세분화 하고, 중복을 배제할 수 있다.
  - 시스템 분석의 질이 향상되고, 시스템 개발의 모든 단계에서 필요한 명세서 작성이 가능
- 자료 흐름도(DFD), 자로사전(DD), 소단위 명세서(Mini-Spec), 개체관계도(ERD), 상태 전이도(STD) 등의 도구 사용

<br>

**2-1. 자료 흐름도(DFD; Data Flow Diagram)**
- 자료의 흐름  및 변환 과정과 기능을 도형 중심으로 기술하는 방법
- 자료 흐름 그래프, 버블 차트라고도 함.
- 구조적 분석 기법에 이용됨
- 자료의 흐름과 기능을 4가지 기본 기호로 표시함   
<br><img src="https://t1.daumcdn.net/cfile/tistory/21513842570C3F6339"><br>

**2-2. 자료 사전(DD; Data Dictionary)**
- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것
- 메타 데이터라고도 함   
<br><img src="https://t1.daumcdn.net/cfile/tistory/2258E840570C401032"><br>

**2-3. 소단위 명세서(Mini-Spec.)**
- 자료 흐름도 상의 최하위 처리 절자를 상세하게 기술하는데 사용하는 도구
- 프로세스 명세서 라고도 함

**2-4. 개체 관계도(ERD; Entity Relationship Diagram)**
- 시스템에서 처리되는 개체(자료)와 개체의 구성과 속성, 개체 간의 관계를 표현하여 개체를 모델화하는 도구
- 개체(Entity), 관계(Relationship), 속서(Attribute) 등이 있음

**2-5. 상태 전이도(STD; State Transition Diagram)**
- 시스템의 상태와 상태의 변화를 모델링하는 것
- 상태 전이도를 통해 개발자는 시스템의 행위를 정의할 수 있음
  
<br>

**3. 요구사항 명세(Requirement Specification)**   
- 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것
- 문서화할 때는 기능 요구사항은 빠짐없이 완전하고 명확하게 해야 하며, 비기능 요구사항은 필요한 것만 명확하게 기술
- 사용자가 이애하기 쉬우며, 개발자가 효과적으로 설계할 수 있도록 작성 (관찰 및 모델 작성 기술)
- 구체적인 명세를 위해 소단위 명세서가 사용될수 있다.

<br>

**4. 요구사항 확인(Requirement Validation, 요구사항 검증)**   
- 요구사항 명세서가 정확하고 안전하게 작성되었는지를 검토
- 개발이 완료된 후 문제가 발견되면 재작업 비용이 발생할 수 있어 꼼꼼한 검증 필요
- 명세서의 내용이 이해하기 쉬운지, 일관성, 회사의 기준, 누락된 기능은 없는지 등을 검증하는 것이 중요

<br>

# 4 요구사항 분석 CASE와 HIPO

### 4.1 요구사항 분석을 위한 CASE(자동화 도구)
- 표준화와 보고를 통한 문서화 품질 개선
- 데이터 베이스가 모두에게 이용 가능하다는 점에서 분석자들 간의 적절한 조정
- 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성
- 변경이 주는 영향 추적의 용이성
- 명세에 대한 유지보수 비용의 축소

<br>

### 4.2 자동화 도구 종류
- **SADT(Structured Analysis and Design Technique)**
  - SoftTech 사에서 개발
  - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구

- **SREM(Software Requirements Engineering Methodology) = RSL/REVS**
  - TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발
  - RSL / REVS를 사용하는 자동화 도구
    - `RSL (REquirement Statement Language)` : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어
      - 요소 : 요구사항 명세를 개발하기 위해 사용되는 개체와 개념
      - 속성 : 요소를 수정하거나 수식하기 위한 것
      - 관계 : 개체들 간의 관계
      - 구조 : 정보 흐름을 묘사하기 위한 것
    - `REVS(Requirement Engineering and Validation System)` : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기

- **PSL(Problem Statement Language) / PSA(Problem Statement Analyzer)**
  - 미시간 대학에서 개발한 것으로 PSL, PSA를 사용하는 자동화 도구
    - PSL : 문제(요구사항) 기술언어
    - PSA : PSL로 기술한 요구사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기

- **TAGS(Technology for Automated Generation of Systems)**
  - 시스템 공학 방법 응용에 대한 자동 접근 방법으로, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구
  - 구성 : IORL, 요구사항 분석과 IORL 처리를 위한 도구
  - IORL : 요구사항 명세 언어

<br>

### 4.3 HIPO
- 시스템의 분석 및 설계나 문서화할 때 사용되는 기법
- 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타냄
- 체계적인 문서관리 가능
- 기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉬움
- 변경, 유지보수가 용이
- 기능과 자료의 의존 관계 동시 표현 가능
- `HIPO Chart` : 시스템 기능 여러개의 고유 모듈들로 분할 하여 이들 간의 인터페이스를 계층구조로 표현한 것

<br>

### 4.4 HIPO Chart의 종류
- 가시적 도표(Visula Table of Contents / 도식목차) : 전첵적인 기능과 흐름을 보여주는 계층(Tree) 구조도
- 총체적 도표(Overview Diagram / 총괄도표, 개요도표) : 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표
- 세부적 도표(Detail Diagram / 상세 도표) : 기본 요소들을 상세히 기술하는 도표


<br>


# 5. UML (Unified Modeling Language)

UML은 시스템 분석, 설계 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
UML의 구성요소에는 사물(Things), 관계(Relationships), 다이어그램(Diagram) 등이 있다.

<br>

### 5.1 사물(Things)
- 모델을 구성하는 가장 중요한 기본 요소, 다이어그램 안에서 관계가 형성될 수 있는 대상
- 구조사물(Structural Things) : 시스템의 개념적, 물리적 요소를 표현 (Class, Use Case, Component, Node 등)
- 행동사물(Behavioral Things) : 시간과 공간에 따른 요소들의 행위를 표현 (Interaction, State Machine 등)
- 그룹사물(Grouping Things) : 요소들을 그룹으로 묶어서 표현 (Package)
- 주해사물(Annotation Things) : 부가적인 설명이나 제약조건 등을 표현 (Note)

<br>

### 5.2 관계(Relationships)
- 사물 사이의 연관성을 표현하는 것
- 연관, 집합, 포함, 일반화, 의존, 실체화 관계등이 있다.
  
- **연관(Association)관계**
  - 2개 이상의 사물이 서로 관련되어 있음을 표현
  - 사물 사이를 실선으로 연결하여 표현, 방향성은 화살표로 표현
  - 양방향 관계의 경우 화살표 생략, 실선으로만 연결
  - 객체의 개수를 의미하는 다중도(Multiplictity)를 선 위에 표기

|다중도|의미|
|:---|:---|
|1|1개의 객체가 연관|
|n|n개의 객체가 연관|
|0..1|연관된 객체가 없거나 1개만 존재|
|0..* 또는 *|연관된 객체가 없거나 다수일 수 있다|
|1..*|연관된 객체가 적어도 1개 이상|
|n..*|연관된 객체가 적어도 n개 이상|
|n..m|연관된 객체가 최소 n개에서 최대 m개|

- **집합(Aggregation)관계**
  - 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현

- **포함(Composition)관계**
  - 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계를 표현

- **일반화(Generalization)관계**
  - 하나의 사물이 다른 사물에 비해 더 일반적인지를 구체적인지를 표현

- **의존(Dependency)관계**
  - 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현

- **실체화(Realization)관계**
  - 사물이 할 수 있거나 해야하는 기능(오퍼레이션, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현
  

<br><img src="https://www.nextree.co.kr/content/images/2021/01/--6-----------.png"><br>



<br>

### 5.3 다이어그램(Diagram)
- 사물과 관계를 도형으로 표현한 것

- 정적 모델링에서는 주로 `구조적 다이어그램` 사용, 동적 모델링에서는 `행위 다이어그램`을 사용 함

- **구조적(Structural) 다이어그램의 종류**
  - **클래스 다이어그램(Class Diagram)**
  
    - 클래스와 클래스가 가지는 속석, 클래스 사이의 관계 표현
    - 시스템의 구조를 파악하고 구조상 문제점을 도출할 수 있다.

  - **객체 다이어그램(Object Diagram)**
  
    - 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현
    - 럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델링에 활용

  - **컴포넌트 다이어그램(Component)**

    - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
    - 구현 단계에서 사용되는 다이어그램

  - **배치 다이어그램(Deployment Diagram)**
    - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
    - 구현 단계에서 사용되는 다이어그램

  - **복합체 구조 다이어그램(composite Structure Diagram)**
    - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현

  - **패키지 다이어그램(Package Diagram)**
    - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현

    <br>
  
- **행위(Behavioral) 다이어그램의 종류**
  - **유스케이스 다이어그램(Use Case Diagram)**
    - 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용
    - 외부 요소와 시스템 간의 상호 작용을 확인
    - 사용자의 요구사항을 분석하기 위한 도구로 사용
    - 시스템의 범위를 파악 할 수 있음
    - 시스템 범위, 액터 유스케이스, 관계로 구성됨

      - 시스템 범위 : 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현
      - 애겉

  - **시퀸스 다이어그램(Sequence Diagram)**
    - 상호 작용하는 시스템이나 객체들이 주고 받는 메시지를 표현

  - **커뮤니케이션 다이어그램(communication Diagram)**
    - 시퀸스 다이어그램과 같이 동작에 참여하는 객체들이 주고 받는 메시지를 표현
    - 객체들 간의 연관까지 표현
  
  - **상태 다이어그램(State Diagram)**
    - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변환하는지를 표현
    - 럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용

  - **활동 다이어그램(Activity Diagram)**
    - 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현

  - **상호작용 개요 다이어그램(Interaction Overview Diagram)**
    - 상호작용 다이어그램 간의 제어 흐름을 표현

  - **타이밍 다이어그램(Timing Diagram)**
    - 객체 상태 변화와 시간 제약을 명시적으로 표현
    - 