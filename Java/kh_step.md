# Chap 1. 객체지향언어



## 자바는 누가 만들었나?

 - 제임스 고슬랭 

## 절차지향언어vs객체지향언어 차이

1. 절차지향언어 
    - 물이 위에서 아래로 흐르는 것처럼 순처적으로 실행되는 프로그래밍 기법. 객체지향 언어보다 속도가 빠름. (단, 하드웨어 소프트웨어 발달로 객체지향 언어가 등장하게 되는 계기)

2. 객체지향언어 
    - 프로그래밍에 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체를 통해 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법.

## 절차지향언어에서 왜? 객체지향언어로 변경되었나?
-	컴퓨터에 입장에서 여러가지 입장을 고려해서 프로그래밍을 하다 보니 절차지향언어는 전문가도 어렵게 느껴졌다. 쉽게 할 수 있는 방법이 없을까? 고안하다가 출시된 것이 객체지향언어 이다.
-	객체는 소리, 공기 등 눈에 보이지 않는 독립적인 단위들을 지칭한다.

## 자바에서 객체(Object)란?
-	컴퓨터가 인식하게 클래스를 통한 new 연산자를 통해 메모리 영역에 생성한 것.

## 클래스 (Class)란?
-	메모리 영역에 생성 할 객체를 찍어내는 설계도, 붕어빵 틀
-	객체의 특성에 대한 정의를 한 것으로 캡슐화를 통해 기능을 포함한 개념
-	프로그램에 필요한 사물이나 개념의 공통 요소를 추상화(abstraction)하여 정의
-	클래스 = 설계도



변수 : 1개의 자료형, 1개의 데이터
배열 : 1개의 자료형, 여러 개의 데이터
구조체 : C언어에서 사용, 여러 개의 자료형, 여러 개의 데이터 ( 자바에서는 사용 X )
객체(Instance) : 현실에 존재하는 독립적이면서 하나로 취급되는 사물이나 개념으로 객체 지향 언어에서 객체의 개념은 클래스에 정의된 내용대로 메모리에 할당된 결과물(Object) 
인스턴스화(instantiation) : 클래스 내의 객체에 대해 특정한 변형을 정의하고 이름을 붙인 다음 그것을 메모리 영역에 위치시키는 것

객체(Instance)의 할당
-	New 연산자와 생성자를 사용하여 객체 생성 시 heap 메모리 공간에 서로 다른 자료형의 데이터가 연속으로 나열/할당된 객체 공간

추상화 (abstraction)
-	유연성을 확보하기 위해 구체적인 것은 제거한다는 의미
-	프로그램에서 필요한 공통점을 추출하고, 불필요한 공통점을 제거하는 과정
-	객체에서 공통된 속성과 행위를 추출한다.

추상화 예시
-	앞 페이지에서 추상화한 결과물을 객체 지향 프로그래밍 언어를 사용해서 변수명(데이터 이름)과 자료형 (데이터 타입) 정리
캡슐화 (Enacpsulation)
-	추상화를 통해 정리된 데이터들과 기능을 하나로 묶어 관리하는 기법
-	클래스의 가장 중요한 목적인 데이터의 접근제한을 원칙으로하여 클래스 외부에서 데이터의 직접 접근을 막고, 대신 데이터를 처리하는 함수들을 클래스 내부에 작성하는 방법
-	보안도 Up. 

캡슐화의 특성
1.	추상화 단위가 된다.
2.	재사용 단위가 된다.
3.	정보은닉을 실현한다.

캡슐화 원칙
1.	클래스의 멤버 변수에 대한 접근 권한은 private를 원칙으로 한다.
2.	클래스의 멤버 변수에 대한 연산처리를 목적으로 하는 함수들을 클래스 내부에 작성한다.
3.	멤버 함수(getter/setter) 는 클래스 밖에서 접근할 수 있도록 public으로 설정한다.

Chap02. 클래스 (Class)

클래스 선언
-	[접근제한자] [예약어] class 클래스명 {
[접급제한자] [예약어] 자료형 변수명 ;
[접급제한자] [예약어] 자료형 변수명 ;

[접근제한자] 생성자명() {}

[접근제한자] 반환형 메소드명(매개변수) {
    // 기능정의
}
실행용 클래스 : 클래스 안에 main 메소드가 존재하여 실행하는 클래스
기능제공 클래스 : 클래스 안에 메소드를 추가하여 필요한 기능이 구현되어 있는 클래스

클래스 접근제한자
-	Public (+) : 같은 패키지 내, 전체 접근 가능
-	하나의 클래스에는 하나의 public 클래스만 가능.
-	(default) (~) : 같은 패키지 내 접근 가능
-	필드영역에서는 사용 불가, 메소드 영역에서 사용 가능,. 필드영역에서는 초기화 블록 생성 후 사용할 것.



Chap03. Package와 import

소스파일 구성 순서
1.	Package문 
2.	Import문
3.	클래스 선언

패키지(Package)란?
-	서로 관련된 클래스 혹은 인터페이스의 묶음으로 패키지는 폴더와 비슷
-	패키지는 서브 패키지를 가질 수 있으며, ‘.’으로 구분
-	이름 없는 패키지는 다른 클래스의 패키지를 사용할 수 없음

Import란?
-	사용할 클래스가 속한 패키지를 지정하는데 사용
-	import문을 사용하면 클래스를 사용할 때 패키지명 생략 가능
-	주의사항 : 이름이 같은 클래스가 속한 두 패키지를 Import 할 때는 클래스 앞에 패키지 명을 붙여 구분해 주어야 한다.







Chap 04 . 필드(Field)

변수의 종류
필드에서는 변수를 선언하게 되며 아래와 같이 구분한다.
1.	클래스 변수 
-	static 키워드를 가지고 필드에 선언하는 변수, 메모리 static영역 사용
-	모든 객체가 공통적으로 속성을 가질 때 사용을 하고 생성할 때 메모리 영역에 같이 생성되기 때문에 꼭 필요한 공통적인 속성을 가진 변수에 사용.
-	[접근제한자] [예약어] 자료형 변수명 [=초기값]
-	클래스 변수를 사용하려고 하면 클래스명을 써주고 .을 입력 후에 해당 클래스 변수, 메소드를 사용할 수 있다.
-	초기화 순서 : JVM 기본값 > 명시적 초기값 > 클래스 초기화 블록 초기값

2.	멤버 변수(인스턴스 변수) 
-	static 키워드 없이 필드에 선언하는 변수, 메모리의 heap 영역 사용
-	각각의 객체(인스턴스)마다 개별적인 속성을 가져야할 때 멤버변수(인스턴스 변수)를 사용
-	[접근제한자] 자료형 변수명 사용 (캡슐화 원칙으로 private사용, 접근제한자 생략시 default)
-	객체를 생성한 후에 heap 메모리 영역에 생성한 후에 변수나 메소드에 접근이 가능.
-	초기화 순서 : JVM 기본값 > 명시적 초기값 > 인스턴스 초기화 블록 초기값 > 생성자를 통한 초기값

3.	지역 변수 
-	메서드, 생성자, 초기화 블록 내부에서 선언하는 변수
 


클래스 초기화 블록
-	인스턴스 블록 ( { } ) : 인스턴스 변수를 초기화 시키는 블록으로 객체 생성시 마다 초기화
-	Static(클래스) 블록 ( static{ } ) : static 필드를 초기화 시키는 블록으로 프로그램 시작 시 한 번만 초기화

Chap 04 . 생성자(Constructor)

생성자는 무엇인가?
-	객체가 new 연산자를 통해 Heap 메모리 영역에 할당될 때 객체 안에서 만들어지는 필드 초기화 
-	생성자는 일종의 메소드로 전달된 초기값을 받아서 객체의 필드에 기록
-	규칙 : 생성자의 선언은 메소드 선언과 유사하나 반환 값이 없으며 생성자명을 클래스명과 똑같이 지정해주어야 함

 

기본생성자 
-	[접근제한자] 클래스명() {}
-	작성하지 않은 경우, 클래스 사용 시 JVM이 자동으로 기본 생성자 생성

매개변수가 있는 생성자 
-	[접근제한자] 클래스명 (매개변수) { this.필드변수 = 매개변수 }
-	객체 생성 시 전달받은 값으로 객체를 초기화 하기 위해 사용
-	매개변수 생성자 작성 시 JVM이 기본 생성자를 자동으로 생성해주지 않음
-	상속에서 사용 시 반드시 기본 생성자를 작성
-	오버로딩을 이용하여 작성
오버로딩이란?
-	한 클래스 내에 동일한 이름의 메소드를 여러 개 작성하는 기법
-	조건은 아래와 같다
1.	메소드의 이름은 동일해야한다.
2.	매개변수의 타입이 달라야 한다.
3.	매개변수의 개수가 달라야 한다.
4.	[주의] 매개변수의 위치가 달라도 다른 메소드라고 인식한다.


This란?
-	모든 인스턴스의 메소드에 숨겨진 채 존재하는 레퍼런스로, 할당된 객체를 가리킴
-	함수 실행 시 전달되는 개체의 주소를 자동으로 받음
-	
 

This() 란?
-	생성자, 같은 클래스의 다른 생성자르 호출할 때 사용, 반드시 첫 번째 줄에 선언해야 함
-	
 



Chap05. 메소드 (Method)

메소드란?
-	수학의 함수와 비슷하며 호출을 통해 사용, 전달 값이 없는 상태로 호출을 하거나 어떤 값을 전달하여 호출을 하며, 함수 내에 작성된 연산 수행
-	수행 후 반환 값 / 결과 값은 있거나 없을 수 있음

메소드 표현식
1.	매개변수가 없고, 리턴값도 없을 때 : [접근제한자] [예약어] void 메소드명() { }
2.	매개변수가 있고, 리턴값이 없을 때 : [접근제한자] [예약어] void 메소드명(매개변수) { }
-	매개변수의 값의 타입은 기본자료형, 배열, 클래스, 가변인자
-	매개변수의 수는 여러 개 일 수 있다. 구분은 ,(콤마) 식별
3.	매개변수가 없고, 리턴값이 있을 때 : [접근제한자] [예약어] 반환형 메소드명() { }
4.	매개변수가 있고, 리턴값이 있을 때 : [접근제한자] [예약어] 반환형 메소드명(매개변수) { }

 

private : 클래스 안에서만 접근 가능 -> 클래스 밖에서 접근 불가능
default : 같은 패키지 안에 있는 다른 클래스들이 접근 가능함 -> 다른 패키지에 있는 클래스는 접근 불가능
protected : default의 범위 + 다른 패키지의 상속 받은 후손 클래스까지 접근 가능 -> 후손클래스 외의 다른 패키지에 있는 클래스는 접근 불가능
public : 공개를 의미함 -> 패키지 안, 밖 모든 클래스가 접근 가능함.

 
 

 


getter / setter 메소드

getter메소드
-	[접근제한자] [예약어] 반환형 get필드명() { return 필드명; }
-	필드에 기록된 값을 읽어서 요청한 쪽으로 읽은 값을 넘기는 메소드

setter메소드
-	필드에 변경할 값을 전달 받아서 필드 값을 변경하는 메소드
-	[접근제한자] [예약어] void set필드명(자료형 변수명) { this.필드명 = 변수명 }

return
-	해당 메소드를 종료하고 자신을 호출한 메소드로 돌아가는 예약어
-	반환 값이 있다면 반환 값을 가지고 자신을 호출한 메소드로 돌아감

 

객체배열
-	객체를 저장하는 배열로 배열의 자료형을 클래스명(사용자 정의 자료형)으로 지정하여 활용
-	선언 : 클래스명[] 배열명;     클래스명 배열명[];
-	할당 : 배열명 = new 클래스명[배열크기]
-	선언과 할당 동시 : 클래스명[] 배열명 = new 클래스명 [배열의크기]
-	인덱스를 이용한 초기화 : 배열명[i] = new 클래스명();
-	선언과 동시에 할당 및 초기화 : 클래스명 배열명[] = { new 클래스명() , new 클래스명()};

 
OOP의 4대 특징
	추상화(Abstraction)
프로그램에서 필요한 공통적인 기능 및 속성들을 추출하고, 불필요한 것을 제거하는 과정.

중요한 건 내가 구현하고자 하는 프로그램이 어떤 프로그램인지, 어떤 목적을 가지고 만드는지 생각할 것!

	캡슐화(Encapsulation)))))
변수 ------- > 배열 ---------------------------- 구조체
값1개         같은 자료형의 값 여러 개 자료형이 다른 변수들의 묶음

	클래스(Class) : 구조체 + 정보은닉(접근에 제한을 설정)
	캡슐화 : 클래스 안의 멤버변수(field)에 클래스 박에서는 접근 못하게 하는 것
         -> private가 원칙!


# 객체 2

## 상속(Inheritance)

1 . 정의
    - 다른 클래스가 가지고 있는 멤버(필드, 메소드)들을 새로 작성할 클래스에서 직접 만들지 않고 상속을 받음으로써 새 클래스가 자신의 멤버처럼 사용할 수 있는 기능
    - extends 키워드 사용
    - 자바는 단일 상속만 지원한다. 클래스간의 관계가 다중 상속보다 명확하고 신뢰성 있는 코드 작성

2. 목적 
    - 클래스의 재사용, 연관된 일련의 클래스들에 대한 공통적인 규약 정의

3. 장점
    1.	보다 적은 양의 코드로 새로운 클래스 작성 가능
    2.	코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
    3.	코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여

4.  특징
    1. 단일상속, 다중상속
        - 모든 클래스는 Object클래스의 후손
        - 클래스간 extends 상속은 단일상속만 허용, 다중상속X
        - 단, 인터페이스 간 extends는 다중상속 허용, 클래스가 인터페이스를 상속받는 implements 상속도 다중상속을 허용
        - Object클래스가 제공하는 메소드를 오버라이딩하여 메소드 재구현 가능
        - Ex) Java.lang.String 클래스의 equals()와 toString()

    1. 부모클래스의 생성자, 초기화 블록은 상속 안됨
        - 자식 클래스 생성 시, 부모 클래스 생성자가 먼저 실행
        - 자식 클래스 생성자 안에서 부모 클래스 생성자 호출을 명시하고 싶으면 super() 활용

    2. 부모의 private멤버는 상속은 되지만 직접 접근 불가
        - 자식 객체 생성 시에 부모의 필드 값도 전달 받은 경우,
        - 자식 생성자 안에서 부모의 private 필드에 직접 접근하여 대입 불가
        - Super() 이용하여 전달 받은 부모 필드 값을 부모 생성자 쪽으로 넘겨서 생성하거나 setter,getter 메소드를 이용하여 접근.


## super()와 super.

1. super(), super(전달값, 전달값...) 생성자
    - 부모 객체의 생성자를 호출하는 메소드로 기본적으로 후손 생성자에 부모 생성자 포함. 
    - 부모 생성자가 가장 먼저 실행되어야 하기 때문에 무조건 첫 줄에 존재해야 한다.
      - 후손클래스 객체 생성시 항상 부모클래스 생성자가 먼서 실행되도록 되어있음
      - 부모클래스에 기본생성자 무조건 쓰기!

2. super. 
    - 상속을 통한 자식 클래스 정의 시 해당 자식 클래스의 부모 객체를 가리키는 참조변수 자식 클래스 내에서 부모 클래스 객체에 접근하여 필드나 메소드 호출 시 사용.
    - 부모클래스의 주소 값을 가리키는 레퍼런스
    - 메소드, 생성자에 숨겨진 채로 존재하여 부모 쪽에 접근하고 싶을 때 사용 가능


## Is A (상속관계) 
 자식 클래스는 (하나의 ) 부모 클래스이다. 
 Ex.) Circle is a Shape. Circle 클래스는 하나의 Shape 클래스이다.


## 오버라이딩vs오버로딩

1. 오버라이딩 (Overriding)
    1. 개념
        - 자식 클래스가 상속 받은 부모 메소드를 재작성 하는 것
        - 부모가 제공하는 기능을 후손이 일부 고쳐 사용하겠다는 의미
  
    2. 특징
        - 메소드 헤드라인 위에 반드시 Annotation, ***@Override*** 표시
        - 후손 객체를 통한 메소드 호출 시 ***후손 것이 우선권을 가짐*** (부모메소드는 자동 은닉)
        - 접근 제어자를 부모 것보다 같거나 넓은 범위로 변경 가능 (단, 부모 클래스의 접근제어가자 private 이라면 오버라이딩 불가)
        - 부모 메소드의 예외처리 클래스 처리범위보다 좁은 범위로 예외처리 클래스 수정가능
   
    3. 성립 조건
        - 부모 클래스의 메소드와 자식 클래스의 메소드 비교 
            - 메소드 이름 동일 
            - 매개변수의 개수,타입,순서 동일 
            - 리턴 타입 동일 (Java 1.5부터는 리턴 타입의 하위 클래스로 변환 가능)

2. 오버로딩 (Overoding)
   1. 개념
       - 한 클래스 내에서 같은 이름의 메소드를 여러개 정의하는 것
   
   2. 성립 조건
        - 같은 메소드 이름
        - 다른 매개변수 선언부 (매개변수 타입, 개수, 순서)
   
   3. 주의사항
        - 메소드의 리턴타입은 오버로딩 조건과 관계 없음
   

## 다형성(Polymorphism)

 - 객체지향 프로그래밍의 3대 특징 중 하나로 '여러 개의 형태를 갖는다'는 의미
 - 하나의 행동으로 여러가지 일을 수행하는 개념
 - 상송을 이용한 기술로 부모 타입으로부터 파생된 여러가지 타입의 자식 객체를 부모 클래스 타입하나로 다룰 수 있는 기술

1. 객체배열과 다형성
    - 다형성을 이용하여 상속 관계에 있는 하나의 부모 클래스 타입의 배열 공간에 여러 종류의 자식 클래스 객체 저장 가능
```

// 다형성 + 배열 적용 
// 다형성을 쓰는 이유는 배열을 만났을때 파워풀한 효과를 내기위해
Hobby[] polyArr = new Hobby[4];
polyArr[0] = new Collecting(3, 100, "유표");
polyArr[1] = new ReadingBook(4, 200, 100);
polyArr[2] = new ReadingBook(5, 300, 200);
polyArr[3] = new Collecting(6, 400, "도자기");

// 객체배열과 다형성
((Collecting)polyArr[0]).colMethod();
((ReadingBook)polyArr[1]).reMethod();
((ReadingBook)polyArr[2]).reMethod();
((Collecting)polyArr[3]).colMethod();
	
//for문 사용 (instanceOf + if문 사용)
	
for(int i = 0 ; i < polyArr.length; i++) {
	if(polyArr[i] instanceof Collecting) {
		((Collecting)polyArr[i]).colMethod();
	} else {
		((ReadingBook)polyArr[i]).reMethod();
	}
}
		

```

2. 매개변수와 다형성
    - 다형성을 이용하여 메소드 호출 시 부모타입의 변수 하나만 사용해 자식 타입의 객체를 받을 수 있음
  
```java

public void execute() {
    driveCar(new Sonate());
    driveCar(new Avante());
}

public void dirveCar(Car c)P{}

```


## 클래스 형변환

1. 업 캐스팅(Up Castion)
    - 상속 관계에 있는 부모, 자식 클래스 간에 부모타입의 참조형 변수가 모든 자식 타입의 객체 주소를 받을 수 있음. 즉, 부모 자료형으로 자식 자료형으로 다룰 수 있다.
    - 자식 객체의 주소를 전달 받은 부모타입의 참조 변수를 통해서 사용할 수 있는 후손의 정보는 **원래 부모타입이었던 멤버만 참조 가능**

2. 다운 캐스틩 (Down Castion)
   - 자식 객체의 주소를 받은 부모 참조형 변수를 가지고 자식의 멤버를 참조해야 할 경우, 부모 클래스 타입의 참조형 변수를 자식 클래스 타입으로 형 변환하는 것
   - 자동으로 처리되지 않기 때문에 반드시 후손 타입 명시해서 형변환해야 한다.
   - 클래스 간의 형 변환은 **반드시 상속 관계에 있는 클래스끼리**만 가능


## instanceof 연산자

- 현재 참조형 변수가 어떤 클래스 형의 객체 주소를 참조하고 있는지 확인 할 때 사용
- 클래스 타입이 맞으면 true, 맞지 않으면 false
- 표현식은 아래와 같다.

```java

if(레버런스 instanceof 클래스타입) {
    //true일때 처리할 내용, 해당 클래스 타입으로 down casting
}

```



## 바인딩
- 실제 실행할 메소드 코드와 호출하는 코드를 연결 시키는 것
- 프로그램이 실행되기 전에 컴파일이 되면서 모든 메소드는 정적 바인딩 됨
  
1. 동적 바인딩
   - 컴파일 시 정적 바인딩된 메소드를 실행할 당시의 객체 타입을 기준으로 바인딩 되는것
   - 성립요건은 아래와 같다
        - 상속 관계로 이루어져 다형성이 적용된 경우, 메소드 오버라이딩이 되어 있으면 정적으로 바인딩 된 메소드 코드보다 오버라이딩 된 메소드 코드를 우선적으로 수행


## final 클래스

 - 상속이 불가능한 클래스
 - 오버라이딩이 불가하다.


## 추상 클래스

1. 추상 클래스 (abstract class)
    - 몸체 없는 메소드를 포함한 클래스
    - 추상 클래스일 경우 클래스 선언부에 abstract 키워드 사용
    - 추상 클래스명으로는 객체화를 시킬수 없다.
    - [접근제한자] abstract class 클래스명

2. 추상 메소드(abstract method) 
    - 몸체 없는 메소드
    - 추상 메소드의 선언부에 abstract 키워드 사용
    - 상속 시 반드시 구현해야 하는, 오버라이딩이 강제화되는 메소드
    - [접근제한자] abstract 반환형 메소드명(자료형 변수명);


3. 추상 클래스 특징
   1. 미완성 클래스 (abstract 키워드 사용)
        - 자체적으로 객체 생성 불가 -> 반드시 상속하여 객체 생성
   2. abstract 메소드가 포함된 클래스는 반드시 abstract 클래스 
        - abstract 메소드가 없어도 abstract 클래스 선언 가능
   3. 클래스 내에 일반 변수, 메소드 포함 가능
   4. 객체 생성은 안되지만 참조형 변수 타입으로는 사용 가능

4. 추상 클래스 장점
   - 일관된 인터페이스 제공
   - 꼭 필요한 기능 강제화(공통적이나 자식클래스에서 특수화 되는 기능)



## 인터페이스

1. 정의
   - 상수형 필드와 추상 메소드만을 작성할 수 있는 추상 클래스의 변형체
   - 메소드의 통일성을 붕여하기 위해 추상 메소드만 따로 모아놓은 것으로 상속 시 인터페이스 내에 정의된 모든 추상메소드 구현해야함

```java

[접근제한자] interface 인터페이스명 {
    // 상수도 멤버로 포함할 수 있음
    public static final 자료형 변수명 = 초기값;

    //추상 메소드만 선언 가능
    [public avstract] 반환자료형 메소드명([자료형 매개변수]);
    //public abstract가 생략되기 때문에 
    //오버라이딩시 반드시 public 표기해야 함

}

```

2. 특징
    1.  모든 인터페이스의 메소드는 묵시적으로 public 이고 abstract
    2.  변수는 묵시적으로 public static final, 따라서 인터페이스 변수의 값 변경 시도 시 컴파일 시 에러 발생
    3.  객체 생성은 안되나 참조형 변수로는 가능

3. 장점
    - 상위 타입 역할로 다형성을 지원하여 연결 ( 마크인터페이스도 이에 해당)
    - 해당 객체가 다양한 기능 제공 시에도 인터페이스에 해당하는 기능만을 사용하게 제한 가능 공통 기능 상의 일관성 제공
    - 공동 작업을 위한 인터페이스 제공